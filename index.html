<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mutated Construct Simulator 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #111827;
            color: white;
            min-height: 100vh;
            overflow: hidden;
        }

        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            background-color: rgba(31, 41, 55, 0.9);
            border-radius: 8px;
            padding: 16px;
            z-index: 100;
            backdrop-filter: blur(4px);
        }

        .hud-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 16px;
            text-align: center;
            margin-bottom: 16px;
        }

        .hud-item {
            display: flex;
            flex-direction: column;
        }

        .hud-label {
            font-weight: bold;
            margin-bottom: 4px;
            font-size: 0.875rem;
        }

        .hud-value {
            font-size: 1.25rem;
            margin-bottom: 4px;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background-color: #374151;
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            transition: width 0.2s;
            border-radius: 3px;
        }

        .progress-willpower {
            background-color: #3b82f6;
        }

        .progress-health {
            background-color: #ef4444;
        }

        .abilities {
            display: flex;
            justify-content: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .ability {
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 0.75rem;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .ability-ready {
            background-color: #d97706;
        }

        .ability-cooldown {
            background-color: #4b5563;
        }

        .ability-active {
            background-color: #dc2626;
        }

        .ability-available {
            background-color: #059669;
        }

        .ability-escape {
            background-color: #eab308;
            animation: pulse 1s infinite;
        }

        .menu-screen, .end-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(17, 24, 39, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(4px);
        }

        .instructions {
            background-color: #1f2937;
            border-radius: 8px;
            padding: 24px;
            margin-bottom: 24px;
            max-width: 600px;
        }

        .instructions h2 {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 16px;
            text-align: center;
            color: #f59e0b;
        }

        .instructions p {
            margin-bottom: 8px;
            font-size: 0.875rem;
        }

        .btn {
            background-color: #d97706;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
            font-size: 1rem;
        }

        .btn:hover {
            background-color: #b45309;
        }

        .btn-blue {
            background-color: #2563eb;
        }

        .btn-blue:hover {
            background-color: #1d4ed8;
        }

        .btn-gray {
            background-color: #4b5563;
        }

        .btn-gray:hover {
            background-color: #374151;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 100;
        }

        .controls button {
            padding: 8px 16px;
            font-size: 0.875rem;
        }

        .vulnerability-indicator {
            position: absolute;
            top: 100px;
            left: 20px;
            background-color: #dc2626;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            animation: pulse 0.5s infinite;
            z-index: 100;
        }

        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 50;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background-color: rgba(255, 255, 255, 0.8);
        }

        .crosshair::before {
            width: 2px;
            height: 20px;
            left: 50%;
            transform: translateX(-50%);
        }

        .crosshair::after {
            height: 2px;
            width: 20px;
            top: 50%;
            transform: translateY(-50%);
        }

        .instructions-3d {
            background-color: #374151;
            padding: 12px;
            border-radius: 4px;
            margin-top: 12px;
        }

        .instructions-3d h3 {
            color: #f59e0b;
            margin-bottom: 8px;
        }

        .end-message {
            background-color: #1f2937;
            border-radius: 8px;
            padding: 24px;
            margin-bottom: 24px;
            text-align: center;
            max-width: 500px;
        }

        .death-message {
            border: 2px solid #dc2626;
        }

        .escape-message {
            border: 2px solid #10b981;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .hidden {
            display: none !important;
        }

        #game-canvas {
            display: block;
            cursor: crosshair;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Menu Screen -->
        <div id="menu-screen" class="menu-screen">
            <div style="text-align: center; margin-bottom: 24px;">
                <h1 style="font-size: 2.5rem; font-weight: bold; color: #f59e0b; margin-bottom: 8px;">
                    Mutated Construct Simulator 3D
                </h1>
                <p style="color: #d1d5db; font-size: 1.125rem;">WoW-style 3D training for raid mechanics</p>
            </div>
            
            <div class="instructions">
                <h2>Instructions</h2>
                <p><strong>Goal:</strong> Survive as a Mutated Construct by managing Willpower and avoiding wiping the raid</p>
                <p><strong>Movement:</strong> WASD (W=forward, S=back, A/Q=strafe left, D/E=strafe right)</p>
                <p><strong>Camera:</strong> Right-click + drag to look around, Mouse wheel to zoom, Drag up for top-down view</p>
                <p><strong>Amber Strike:</strong> Click on enemies (interrupts casts, deals damage)</p>
                <p><strong>Struggle for Control:</strong> Spacebar (costs 8 Willpower, stuns you briefly, makes you vulnerable)</p>
                <p><strong>Consume Amber:</strong> F key when near amber pools (restores 20 Willpower)</p>
                <p><strong>Break Free:</strong> R key when health is ≤20%</p>
                <p><strong>CRITICAL:</strong> You will be forced to cast Amber Explosion every 15 seconds - use Struggle for Control to interrupt it or you'll wipe the raid!</p>
                <p><strong>Willpower:</strong> Drains 2 per second - don't let it reach 0!</p>
                
                <div class="instructions-3d">
                    <h3>3D Navigation Tips:</h3>
                    <p>• Use right-click + mouse to rotate camera just like WoW</p>
                    <p>• Drag mouse up while right-clicking for top-down raid view</p>
                    <p>• Movement is relative to where your camera is facing</p>
                    <p>• Click enemies when your crosshair is over them</p>
                    <p>• Practice moving and turning simultaneously</p>
                </div>
            </div>
            
            <button id="start-btn" class="btn">▶ Start 3D Simulation</button>
        </div>

        <!-- Game Screen -->
        <div id="game-screen" class="hidden">
            <!-- HUD -->
            <div class="hud">
                <div class="hud-grid">
                    <div class="hud-item">
                        <div class="hud-label" style="color: #3b82f6;">Willpower</div>
                        <div id="willpower-value" class="hud-value">100/100</div>
                        <div class="progress-bar">
                            <div id="willpower-bar" class="progress-fill progress-willpower" style="width: 100%;"></div>
                        </div>
                    </div>
                    <div class="hud-item">
                        <div class="hud-label" style="color: #ef4444;">Health</div>
                        <div id="health-value" class="hud-value">100/100</div>
                        <div class="progress-bar">
                            <div id="health-bar" class="progress-fill progress-health" style="width: 100%;"></div>
                        </div>
                    </div>
                    <div class="hud-item">
                        <div class="hud-label" style="color: #f59e0b;">Score</div>
                        <div id="score-value" class="hud-value">0</div>
                    </div>
                    <div class="hud-item">
                        <div class="hud-label" style="color: #10b981;">Time</div>
                        <div id="time-value" class="hud-value">0s</div>
                    </div>
                </div>
                
                <div class="abilities">
                    <div id="amber-strike-ability" class="ability ability-ready">
                        ⚡ Amber Strike (Ready)
                    </div>
                    <div id="struggle-ability" class="ability ability-ready">
                        🛡 Struggle (8 WP)
                    </div>
                    <div id="consume-ability" class="ability ability-cooldown hidden">
                        💧 Press F to consume amber
                    </div>
                    <div id="break-free-ability" class="ability ability-escape hidden">
                        Press R to Break Free!
                    </div>
                </div>
            </div>

            <!-- Crosshair -->
            <div class="crosshair"></div>

            <!-- Vulnerability Indicator -->
            <div id="vulnerability-indicator" class="vulnerability-indicator hidden">
                VULNERABLE! (<span id="vulnerability-time">5</span>s)
            </div>

            <!-- Amber Explosion Cast Bar -->
            <div id="amber-explosion-cast" class="hidden" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 200; background-color: rgba(220, 38, 38, 0.9); padding: 16px; border-radius: 8px; text-align: center; border: 3px solid #dc2626;">
                <div style="color: white; font-weight: bold; margin-bottom: 8px; font-size: 1.25rem;">CASTING AMBER EXPLOSION!</div>
                <div style="color: white; margin-bottom: 8px;">Use Struggle for Control (SPACEBAR) to interrupt!</div>
                <div style="width: 300px; height: 12px; background-color: #7f1d1d; border-radius: 6px; overflow: hidden;">
                    <div id="amber-explosion-progress" style="height: 100%; background-color: #fbbf24; transition: width 0.1s; border-radius: 6px;"></div>
                </div>
                <div id="amber-explosion-timer" style="color: white; font-weight: bold; margin-top: 4px;">4.0s</div>
            </div>

            <!-- Game Canvas -->
            <canvas id="game-canvas"></canvas>

            <!-- Controls -->
            <div class="controls">
                <button id="pause-btn" class="btn btn-blue">⏸</button>
                <button id="reset-btn" class="btn btn-gray">↻</button>
            </div>
        </div>

        <!-- End Screen -->
        <div id="end-screen" class="end-screen hidden">
            <div id="end-message" class="end-message">
                <h2 id="end-title">Game Over</h2>
                <p id="end-description">Description</p>
                <p id="end-stats" style="font-size: 1.125rem; font-weight: bold; margin-top: 12px;">Stats</p>
            </div>
            <button id="try-again-btn" class="btn">Try Again</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game state
        let gameState = 'menu';
        let willpower = 100;
        let health = 100;
        let maxHealth = 100;
        let damageVulnerable = false;
        let vulnerabilityTimer = 0;
        let gameTime = 0;
        let score = 0;
        let enemiesKilled = 0;
        let gameLoopInterval = null;
        let isPaused = false;

        // Ability states
        let amberStrikeCooldown = 0;
        let strugglingForControl = false;
        let struggleTimer = 0;

        // Amber Explosion self-cast mechanic
        let castingAmberExplosion = false;
        let amberExplosionCastTime = 0;
        let lastAmberExplosionTime = 0;

        // Game objects
        let enemies = [];
        let amberPools = [];

        // 3D Scene variables
        let scene, camera, renderer, player;
        let enemyMeshes = [];
        let poolMeshes = [];
        let raycaster, mouse;

        // Movement and camera
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let strafeLeft = false, strafeRight = false;
        let mouseDown = false;
        let cameraRotation = { x: 0, y: 0 };
        let cameraDistance = 8;
        let playerPosition = { x: 0, z: 0 };
        let playerRotation = 0;

        // Constants
        const WILLPOWER_DRAIN_RATE = 2;
        const AMBER_STRIKE_COOLDOWN = 2000;
        const STRUGGLE_COST = 8;
        const STRUGGLE_DURATION = 500;
        const VULNERABILITY_DURATION = 5000;
        const AMBER_POOL_RESTORE = 20;
        const BREAK_FREE_THRESHOLD = 20;
        const MOVE_SPEED = 0.18; // Adjusted for proper raid room scale
        const AMBER_EXPLOSION_CAST_TIME = 4000; // 4 second cast
        const AMBER_EXPLOSION_INTERVAL = 15000; // Force cast every 15 seconds

        // DOM elements
        const menuScreen = document.getElementById('menu-screen');
        const gameScreen = document.getElementById('game-screen');
        const endScreen = document.getElementById('end-screen');
        const canvas = document.getElementById('game-canvas');

        // Initialize 3D scene
        function init3D() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2a1810);
            scene.fog = new THREE.Fog(0x2a1810, 10, 50);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Ground - larger raid-sized room (approximately 50x50 yards)
            const groundGeometry = new THREE.PlaneGeometry(60, 60);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x3a3a3a });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Player
            const playerGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.2, 8);
            const playerMaterial = new THREE.MeshLambertMaterial({ color: 0xf59e0b });
            player = new THREE.Mesh(playerGeometry, playerMaterial);
            player.position.set(0, 0.6, 0);
            player.castShadow = true;
            scene.add(player);

            // Raycaster for mouse interactions
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Position camera
            updateCamera();
        }

        // Update camera position (third-person)
        function updateCamera() {
            const offsetX = Math.sin(cameraRotation.y) * cameraDistance;
            const offsetZ = Math.cos(cameraRotation.y) * cameraDistance;
            const offsetY = 3 + Math.sin(cameraRotation.x) * 2;

            camera.position.set(
                playerPosition.x + offsetX,
                offsetY,
                playerPosition.z + offsetZ
            );
            camera.lookAt(playerPosition.x, 0.6, playerPosition.z);
        }

        // Create enemy mesh
        function createEnemy(enemy) {
            const geometry = new THREE.BoxGeometry(1, 1.5, 1);
            const material = new THREE.MeshLambertMaterial({ 
                color: enemy.casting ? 0xdc2626 : 0x7c3aed 
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(enemy.x, 0.75, enemy.z);
            mesh.castShadow = true;
            mesh.userData = { id: enemy.id, type: 'enemy' };

            // Cast indicator
            if (enemy.casting) {
                const indicatorGeometry = new THREE.RingGeometry(0.5, 0.7, 8);
                const indicatorMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff0000, 
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.7
                });
                const indicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);
                indicator.rotation.x = -Math.PI / 2;
                indicator.position.y = 0.1;
                mesh.add(indicator);
            }

            scene.add(mesh);
            return mesh;
        }

        // Create amber pool mesh
        function createAmberPool(pool) {
            const geometry = new THREE.SphereGeometry(0.4, 8, 6);
            const material = new THREE.MeshLambertMaterial({ 
                color: 0xfbbf24,
                emissive: 0x332200
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(pool.x, 0.4, pool.z);
            mesh.userData = { id: pool.id, type: 'pool' };
            
            // Add glow effect
            const glowGeometry = new THREE.SphereGeometry(0.6, 8, 6);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xfbbf24,
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            mesh.add(glow);

            scene.add(mesh);
            return mesh;
        }

        // Initialize game
        function initializeGame() {
            willpower = 100;
            health = 100;
            maxHealth = 100;
            damageVulnerable = false;
            vulnerabilityTimer = 0;
            gameTime = 0;
            score = 0;
            enemiesKilled = 0;
            amberStrikeCooldown = 0;
            strugglingForControl = false;
            struggleTimer = 0;
            castingAmberExplosion = false;
            amberExplosionCastTime = 0;
            lastAmberExplosionTime = 0;
            playerPosition = { x: 0, z: 0 };
            playerRotation = 0;
            isPaused = false;

            // Clear existing meshes
            enemyMeshes.forEach(mesh => scene.remove(mesh));
            poolMeshes.forEach(mesh => scene.remove(mesh));
            enemyMeshes = [];
            poolMeshes = [];

            // Create initial enemies - spread out for larger room
            enemies = [
                { id: 1, x: -8, z: -12, health: 100, maxHealth: 100, casting: false, castTime: 0 },
                { id: 2, x: 8, z: -12, health: 100, maxHealth: 100, casting: false, castTime: 0 },
                { id: 3, x: -8, z: 12, health: 100, maxHealth: 100, casting: false, castTime: 0 },
                { id: 4, x: 8, z: 12, health: 100, maxHealth: 100, casting: false, castTime: 0 }
            ];

            // Create initial amber pools - spread around the larger room
            amberPools = [
                { id: 1, x: -15, z: 15, consumed: false },
                { id: 2, x: 15, z: 15, consumed: false },
                { id: 3, x: 0, z: -18, consumed: false },
                { id: 4, x: -15, z: -15, consumed: false },
                { id: 5, x: 15, z: -15, consumed: false }
            ];

            updateGameObjects();
            updateUI();
        }

        // Update 3D game objects
        function updateGameObjects() {
            // Update player position
            player.position.set(playerPosition.x, 0.6, playerPosition.z);
            player.rotation.y = playerRotation;

            // Update player material based on state
            if (strugglingForControl) {
                player.material.color.setHex(0xdc2626);
                player.material.emissive.setHex(0x220000);
            } else if (damageVulnerable) {
                player.material.color.setHex(0xf97316);
                player.material.emissive.setHex(0x331100);
            } else {
                player.material.color.setHex(0xf59e0b);
                player.material.emissive.setHex(0x000000);
            }

            // Update enemies
            enemyMeshes.forEach(mesh => scene.remove(mesh));
            enemyMeshes = [];
            enemies.forEach(enemy => {
                if (enemy.health > 0) {
                    enemyMeshes.push(createEnemy(enemy));
                }
            });

            // Update amber pools
            poolMeshes.forEach(mesh => scene.remove(mesh));
            poolMeshes = [];
            amberPools.forEach(pool => {
                if (!pool.consumed) {
                    poolMeshes.push(createAmberPool(pool));
                }
            });

            updateCamera();
        }

        // Update UI
        function updateUI() {
            document.getElementById('willpower-value').textContent = `${Math.ceil(willpower)}/100`;
            document.getElementById('willpower-bar').style.width = `${willpower}%`;
            
            document.getElementById('health-value').textContent = `${Math.ceil(health)}/${Math.ceil(maxHealth)}`;
            document.getElementById('health-bar').style.width = `${(health/maxHealth) * 100}%`;
            
            document.getElementById('score-value').textContent = score;
            document.getElementById('time-value').textContent = `${Math.floor(gameTime/1000)}s`;

            // Update abilities
            const amberStrikeAbility = document.getElementById('amber-strike-ability');
            if (amberStrikeCooldown > 0) {
                amberStrikeAbility.textContent = `⚡ Amber Strike (${Math.ceil(amberStrikeCooldown/1000)}s)`;
                amberStrikeAbility.className = 'ability ability-cooldown';
            } else {
                amberStrikeAbility.textContent = '⚡ Amber Strike (Ready)';
                amberStrikeAbility.className = 'ability ability-ready';
            }

            const struggleAbility = document.getElementById('struggle-ability');
            if (strugglingForControl) {
                struggleAbility.textContent = '🛡 Struggle (Active)';
                struggleAbility.className = 'ability ability-active';
            } else if (willpower >= STRUGGLE_COST) {
                struggleAbility.textContent = '🛡 Struggle (8 WP)';
                struggleAbility.className = 'ability ability-ready';
            } else {
                struggleAbility.textContent = '🛡 Struggle (8 WP)';
                struggleAbility.className = 'ability ability-cooldown';
            }

            // Check for nearby amber pools
            const nearbyPools = amberPools.filter(pool => {
                if (pool.consumed) return false;
                const distance = Math.sqrt(
                    Math.pow(pool.x - playerPosition.x, 2) + 
                    Math.pow(pool.z - playerPosition.z, 2)
                );
                return distance <= 3; // Slightly larger range for bigger room
            });

            const consumeAbility = document.getElementById('consume-ability');
            if (nearbyPools.length > 0) {
                consumeAbility.classList.remove('hidden');
            } else {
                consumeAbility.classList.add('hidden');
            }

            // Break free ability
            const breakFreeAbility = document.getElementById('break-free-ability');
            if (health <= BREAK_FREE_THRESHOLD) {
                breakFreeAbility.classList.remove('hidden');
            } else {
                breakFreeAbility.classList.add('hidden');
            }

            // Vulnerability indicator
            const vulnIndicator = document.getElementById('vulnerability-indicator');
            if (damageVulnerable) {
                vulnIndicator.classList.remove('hidden');
                document.getElementById('vulnerability-time').textContent = Math.ceil(vulnerabilityTimer/1000);
            } else {
                vulnIndicator.classList.add('hidden');
            }
        }

        // Game loop
        function gameLoop() {
            if (gameState !== 'playing' || isPaused) return;

            gameTime += 100;

            // Drain willpower
            willpower -= (WILLPOWER_DRAIN_RATE * 0.1);
            if (willpower <= 0.1) { // Changed from <= 0 to avoid floating point precision issues
                willpower = 0;
                gameState = 'dead';
                showEndScreen();
                return;
            }

            // Update cooldowns
            amberStrikeCooldown = Math.max(0, amberStrikeCooldown - 100);
            vulnerabilityTimer = Math.max(0, vulnerabilityTimer - 100);
            struggleTimer = Math.max(0, struggleTimer - 100);

            // Update struggle state
            strugglingForControl = strugglingForControl && struggleTimer > 0;

            // Remove vulnerability when timer expires
            if (vulnerabilityTimer <= 0) {
                damageVulnerable = false;
            }

            // Amber Explosion self-cast mechanic
            if (!castingAmberExplosion && gameTime - lastAmberExplosionTime > AMBER_EXPLOSION_INTERVAL) {
                // Force player to start casting Amber Explosion
                castingAmberExplosion = true;
                amberExplosionCastTime = AMBER_EXPLOSION_CAST_TIME;
                lastAmberExplosionTime = gameTime;
            }

            if (castingAmberExplosion) {
                amberExplosionCastTime -= 100;
                if (amberExplosionCastTime <= 0) {
                    // Amber Explosion completes - raid wipe!
                    gameState = 'dead';
                    showEndScreen('explosion');
                    return;
                }
            }

            // Handle movement
            handleMovement();

            // Enemy AI
            enemies.forEach((enemy, index) => {
                if (enemy.health <= 0) return;

                // Start casting
                if (!enemy.casting && Math.random() < 0.005) {
                    enemies[index] = { ...enemy, casting: true, castTime: 3000 };
                    return;
                }

                // Update cast time
                if (enemy.casting) {
                    const newCastTime = enemy.castTime - 100;
                    if (newCastTime <= 0) {
                        // Cast completed - deal damage
                        if (!strugglingForControl && !castingAmberExplosion) {
                            const damage = damageVulnerable ? 40 : 20;
                            health = Math.max(0, health - damage);
                            if (health <= 0) {
                                gameState = 'dead';
                                showEndScreen('health');
                                return;
                            }
                        }
                        enemies[index] = { ...enemy, casting: false, castTime: 0 };
                    } else {
                        enemies[index] = { ...enemy, castTime: newCastTime };
                    }
                }
            });

            // Spawn new amber pools occasionally
            if (Math.random() < 0.002) {
                const newId = Math.max(...amberPools.map(p => p.id), 0) + 1;
                amberPools.push({
                    id: newId,
                    x: -25 + Math.random() * 50,
                    z: -25 + Math.random() * 50,
                    consumed: false
                });
            }

            updateGameObjects();
            updateUI();
        }

        // Handle movement
        function handleMovement() {
            if (strugglingForControl || castingAmberExplosion) return;

            const moveVector = new THREE.Vector3();
            
            if (moveForward) moveVector.z -= MOVE_SPEED;
            if (moveBackward) moveVector.z += MOVE_SPEED;
            if (moveLeft || strafeLeft) moveVector.x -= MOVE_SPEED;
            if (moveRight || strafeRight) moveVector.x += MOVE_SPEED;

            // Rotate movement relative to camera
            moveVector.applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraRotation.y);
            
            playerPosition.x += moveVector.x;
            playerPosition.z += moveVector.z;

            // Keep player in bounds - larger room
            playerPosition.x = Math.max(-28, Math.min(28, playerPosition.x));
            playerPosition.z = Math.max(-28, Math.min(28, playerPosition.z));

            // Update player rotation to face movement direction
            if (moveVector.length() > 0) {
                playerRotation = Math.atan2(moveVector.x, moveVector.z);
            }
        }

        // Abilities
        function useAmberStrike(targetId) {
            if (amberStrikeCooldown > 0 || strugglingForControl || gameState !== 'playing') return;

            amberStrikeCooldown = AMBER_STRIKE_COOLDOWN;

            enemies.forEach((enemy, index) => {
                if (enemy.id === targetId) {
                    const newHealth = Math.max(0, enemy.health - 50);
                    if (newHealth === 0) {
                        enemiesKilled++;
                        score += 100;
                    }
                    enemies[index] = { ...enemy, health: newHealth, casting: false, castTime: 0 };
                }
            });
        }

        function useStruggleForControl() {
            if (willpower < STRUGGLE_COST || strugglingForControl || gameState !== 'playing') return;

            willpower -= STRUGGLE_COST;
            strugglingForControl = true;
            struggleTimer = STRUGGLE_DURATION;
            damageVulnerable = true;
            vulnerabilityTimer = VULNERABILITY_DURATION;

            // Interrupt Amber Explosion cast - CRITICAL MECHANIC!
            if (castingAmberExplosion) {
                castingAmberExplosion = false;
                amberExplosionCastTime = 0;
                score += 200; // Bonus points for saving the raid!
            }

            // Interrupt all enemy casts
            enemies.forEach((enemy, index) => {
                enemies[index] = { ...enemy, casting: false, castTime: 0 };
            });
        }

        function consumeAmberPool(poolId) {
            const pool = amberPools.find(p => p.id === poolId && !p.consumed);
            if (!pool || strugglingForControl || castingAmberExplosion || gameState !== 'playing') return;

            const distance = Math.sqrt(
                Math.pow(pool.x - playerPosition.x, 2) + 
                Math.pow(pool.z - playerPosition.z, 2)
            );

            if (distance <= 3) { // Adjusted for larger room
                pool.consumed = true;
                willpower = Math.min(100, willpower + AMBER_POOL_RESTORE);
                maxHealth += 20;
                health += 20;
                score += 50;
            }
        }

        function breakFree() {
            if (health > BREAK_FREE_THRESHOLD || gameState !== 'playing') return;
            gameState = 'escaped';
            showEndScreen();
        }

        // Show end screen
        function showEndScreen(deathType = 'willpower') {
            clearInterval(gameLoopInterval);
            gameScreen.classList.add('hidden');
            endScreen.classList.remove('hidden');

            const endMessage = document.getElementById('end-message');
            const endTitle = document.getElementById('end-title');
            const endDescription = document.getElementById('end-description');
            const endStats = document.getElementById('end-stats');

            if (gameState === 'dead') {
                endMessage.className = 'end-message death-message';
                if (deathType === 'explosion') {
                    endTitle.textContent = 'Amber Explosion - Raid Wiped!';
                    endDescription.textContent = 'You failed to interrupt your Amber Explosion cast and killed the raid!';
                } else if (deathType === 'health') {
                    endTitle.textContent = 'Construct Destroyed!';
                    endDescription.textContent = 'Your health reached zero from enemy attacks!';
                } else {
                    endTitle.textContent = 'Construct Destroyed!';
                    endDescription.textContent = 'Your Willpower reached zero and you lost control.';
                }
            } else if (gameState === 'escaped') {
                endMessage.className = 'end-message escape-message';
                endTitle.textContent = 'Successfully Escaped!';
                endDescription.textContent = 'You broke free from the construct form!';
            }

            endStats.textContent = `Score: ${score} | Enemies Killed: ${enemiesKilled} | Time: ${Math.floor(gameTime/1000)}s`;
        }

        // Mouse controls
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 2) { // Right click
                mouseDown = true;
                canvas.requestPointerLock();
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (e.button === 2) {
                mouseDown = false;
                document.exitPointerLock();
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (mouseDown) {
                cameraRotation.y -= e.movementX * 0.005;
                cameraRotation.x += e.movementY * 0.005; // Inverted to match WoW defaults
                // Allow much more vertical range for top-down view
                cameraRotation.x = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/3, cameraRotation.x));
            }
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            cameraDistance = Math.max(3, Math.min(15, cameraDistance + e.deltaY * 0.01));
        });

        canvas.addEventListener('click', (e) => {
            if (gameState !== 'playing' || e.button === 2) return;

            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([...enemyMeshes, ...poolMeshes], true);

            if (intersects.length > 0) {
                const object = intersects[0].object;
                if (object.userData.type === 'enemy') {
                    useAmberStrike(object.userData.id);
                } else if (object.userData.type === 'pool') {
                    consumeAmberPool(object.userData.id);
                }
            }
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (gameState !== 'playing' || isPaused) return;

            switch(e.key.toLowerCase()) {
                case 'w':
                    moveForward = true;
                    break;
                case 's':
                    moveBackward = true;
                    break;
                case 'a':
                case 'q':
                    if (e.key.toLowerCase() === 'a') moveLeft = true;
                    if (e.key.toLowerCase() === 'q') strafeLeft = true;
                    break;
                case 'd':
                case 'e':
                    if (e.key.toLowerCase() === 'd') moveRight = true;
                    if (e.key.toLowerCase() === 'e') strafeRight = true;
                    break;
                case ' ':
                    e.preventDefault();
                    useStruggleForControl();
                    break;
                case 'f':
                    e.preventDefault();
                    const nearbyPool = amberPools.find(pool => {
                        if (pool.consumed) return false;
                        const distance = Math.sqrt(
                            Math.pow(pool.x - playerPosition.x, 2) + 
                            Math.pow(pool.z - playerPosition.z, 2)
                        );
                        return distance <= 3; // Adjusted for larger room
                    });
                    if (nearbyPool) consumeAmberPool(nearbyPool.id);
                    break;
                case 'r':
                    e.preventDefault();
                    if (health <= BREAK_FREE_THRESHOLD) breakFree();
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch(e.key.toLowerCase()) {
                case 'w':
                    moveForward = false;
                    break;
                case 's':
                    moveBackward = false;
                    break;
                case 'a':
                    moveLeft = false;
                    break;
                case 'q':
                    strafeLeft = false;
                    break;
                case 'd':
                    moveRight = false;
                    break;
                case 'e':
                    strafeRight = false;
                    break;
            }
        });

        // Render loop
        function animate() {
            requestAnimationFrame(animate);
            if (gameState === 'playing' && !isPaused) {
                renderer.render(scene, camera);
            }
        }

        // Event listeners
        document.getElementById('start-btn').onclick = () => {
            // Safety: Clear any existing interval before starting
            if (gameLoopInterval) {
                clearInterval(gameLoopInterval);
            }
            
            menuScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            gameState = 'playing';
            init3D();
            initializeGame();
            gameLoopInterval = setInterval(gameLoop, 100);
            animate();
        };

        document.getElementById('pause-btn').onclick = () => {
            isPaused = !isPaused;
            document.getElementById('pause-btn').textContent = isPaused ? '▶' : '⏸';
        };

        document.getElementById('reset-btn').onclick = () => {
            clearInterval(gameLoopInterval);
            gameScreen.classList.add('hidden');
            menuScreen.classList.remove('hidden');
            gameState = 'menu';
        };

        document.getElementById('try-again-btn').onclick = () => {
            clearInterval(gameLoopInterval); // Fix: Clear the interval!
            endScreen.classList.add('hidden');
            menuScreen.classList.remove('hidden');
            gameState = 'menu';
        };

        // Handle window resize
        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });
    </script>
</body>
</html>
